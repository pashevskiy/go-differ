package main

func main() {
	text1 := "// Convert Docker Compose v3 ports to kobject.Ports\n// expose ports will be treated as TCP ports\nfunc loadV3Ports(ports []types.ServicePortConfig, expose []string) []kobject.Ports {\n\tkomposePorts := []kobject.Ports{}\n\n\texist := map[string]bool{}\n\n\tfor _, port := range ports {\n\n\t\t// Convert to a kobject struct with ports\n\t\t// NOTE: V3 doesn't use IP (they utilize Swarm instead for host-networking).\n\t\t// Thus, IP is blank.\n\t\tkomposePorts = append(komposePorts, kobject.Ports{\n\t\t\tHostPort:      int32(port.Published),\n\t\t\tContainerPort: int32(port.Target),\n\t\t\tHostIP:        \"\",\n\t\t\tProtocol:      corev1.Protocol(strings.ToUpper(string(port.Protocol))),\n\t\t})\n\n\t\texist[cast.ToString(port.Target)+strings.ToUpper(string(port.Protocol))] = true\n\n\t}\n\n\tif expose != nil {\n\t\tfor _, port := range expose {\n\t\t\tportValue := port\n\t\t\tprotocol := corev1.ProtocolTCP\n\t\t\tif strings.Contains(portValue, \"/\") {\n\t\t\t\tsplits := strings.Split(port, \"/\")\n\t\t\t\tportValue = splits[0]\n\t\t\t\tprotocol = corev1.Protocol(strings.ToUpper(splits[1]))\n\t\t\t}\n\n\t\t\tif exist[portValue+string(protocol)] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tkomposePorts = append(komposePorts, kobject.Ports{\n\t\t\t\tHostPort:      cast.ToInt32(portValue),\n\t\t\t\tContainerPort: cast.ToInt32(portValue),\n\t\t\t\tHostIP:        \"\",\n\t\t\t\tProtocol:      protocol,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn komposePorts\n}"
	text2 := "// Convert Docker Compose v3 ports to kobject.Ports\n// expose ports will be treated as TCP ports\nfunc loadV3Ports(ports []types.ServicePortConfig, expose []string) []kobject.Ports {\n\tkomposePorts := []kobject.Ports{}\n\n\texist := map[string]bool{}\n\n\tfor _, port := range ports {\n\n\t\t// Convert to a kobject struct with ports\n\t\t// NOTE: V3 doesn't use IP (they utilize Swarm instead for host-networking).\n\t\t// Thus, IP is blank.\n\t\tkomposePorts = append(komposePorts, kobject.Ports{\n\t\t\tHostPort:      int32(port.Published),\n\t\t\tContainerPort: int32(port.Target),\n\t\t\tHostIP:        \"\",\n\t\t\tProtocol:      corev1.Protocol(strings.ToUpper(string(port.Protocol))),\n\t\t})\n\n\t\texist[cast.ToString(port.Target)+strings.ToUpper(string(port.Protocol))] = true\n\n\t}\n\n\tfor _, port := range expose {\n\t\tportValue := port\n\t\tprotocol := corev1.ProtocolTCP\n\t\tif strings.Contains(portValue, \"/\") {\n\t\t\tsplits := strings.Split(port, \"/\")\n\t\t\tportValue = splits[0]\n\t\t\tprotocol = corev1.Protocol(strings.ToUpper(splits[1]))\n\t\t}\n\n\t\tif exist[portValue+string(protocol)] {\n\t\t\tcontinue\n\t\t}\n\t\tkomposePorts = append(komposePorts, kobject.Ports{\n\t\t\tHostPort:      cast.ToInt32(portValue),\n\t\t\tContainerPort: cast.ToInt32(portValue),\n\t\t\tHostIP:        \"\",\n\t\t\tProtocol:      protocol,\n\t\t})\n\t}\n\n\treturn komposePorts\n}"

	diff := NewDiffLines(text1, text2)
	PrintDiff(diff, HideMatchedLines{3})
}